<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Precompute CLIP Embeddings</title>
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
  <style>
    body { font: 14px/1.4 system-ui, sans-serif; padding: 16px; }
    #log { white-space: pre-wrap; background:#111; color:#0f0; padding:12px; border-radius:8px; height: 50vh; overflow:auto; }
  </style>
</head>
<body>
  <h1>Sprite Embedding Precompute (CLIP)</h1>
  <p>Needs: <code>drive_cache.json</code> and <code>models/clip-vit-b32.onnx</code> in <code>public/</code>.</p>
  <button id="run">Run</button>
  <div id="log"></div>
  <script>
    const log = (m) => { const el = document.getElementById('log'); el.textContent += m + "\n"; el.scrollTop = el.scrollHeight; };

    async function getSession() {
      return await ort.InferenceSession.create("models/clip-vit-b32.onnx", { executionProviders:["webgl","wasm"] });
    }

    function loadImage(src) {
      return new Promise((res, rej) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = () => res(img);
        img.onerror = rej;
        img.src = src;
      });
    }

    function centerCropTo(img, size = 224) {
      const canvas = document.createElement("canvas");
      canvas.width = size; canvas.height = size;
      const ctx = canvas.getContext("2d");
      const scale = Math.max(size / img.width, size / img.height);
      const w = img.width * scale;
      const h = img.height * scale;
      const dx = (size - w) / 2;
      const dy = (size - h) / 2;
      ctx.imageSmoothingEnabled = true;
      ctx.drawImage(img, dx, dy, w, h);
      return ctx.getImageData(0, 0, size, size);
    }

    function chwFloat32(id) {
      const mean = [0.48145466, 0.4578275, 0.40821073];
      const std  = [0.26862954, 0.26130258, 0.27577711];
      const { width: W, height: H, data } = id;
      const out = new Float32Array(3 * H * W);
      const stride = H * W;
      for (let y = 0, i = 0; y < H; y++) {
        for (let x = 0; x < W; x++, i++) {
          const j = (y * W + x) * 4;
          const r = data[j] / 255, g = data[j+1] / 255, b = data[j+2] / 255;
          out[0 * stride + i] = (r - mean[0]) / std[0];
          out[1 * stride + i] = (g - mean[1]) / std[1];
          out[2 * stride + i] = (b - mean[2]) / std[2];
        }
      }
      return out;
    }

    function l2normalize(v) {
      let s = 0; for (let i=0;i<v.length;i++) s += v[i]*v[i];
      const n = Math.sqrt(Math.max(s,1e-12));
      for (let i=0;i<v.length;i++) v[i] /= n;
      return v;
    }

    async function embed(src, session) {
      const img = await loadImage(src);
      const id = centerCropTo(img, 224);
      const x = chwFloat32(id);
      const tensor = new ort.Tensor("float32", x, [1,3,224,224]);
      const outputs = await session.run({ "input": tensor });
      const out = outputs["pooled_output"] || outputs["last_hidden_state"] || Object.values(outputs)[0];
      let vec;
      if (out.dims.length === 2) vec = out.data;
      else vec = out.data.subarray(0, out.dims[2]);
      return Array.from(l2normalize(new Float32Array(vec)));
    }

    document.getElementById('run').onclick = async () => {
      try {
        log("Loading cache and model…");
        const [cacheRes, session] = await Promise.all([
          fetch("drive_cache.json", { cache: "no-store" }),
          getSession()
        ]);
        const cache = await cacheRes.json();
        const keys = Object.keys(cache);
        log(`Sprites: ${keys.length}`);

        const rows = [];
        let done = 0;
        for (const k of keys) {
          const c = cache[k];
          const src = c.src || c.url;
          if (!src) continue;
          try {
            const vec = await embed(src, session);
            rows.push({ key: k, name: c.name || k, src, vec });
            done++;
            if (done % 25 === 0) log(`Embedded ${done}/${keys.length}`);
          } catch (e) {
            log(`Skip ${k}: ${e}`);
          }
        }

        const blob = new Blob([JSON.stringify(rows)], { type: "application/json" });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = "sprite_index_clip.json";
        a.click();
        URL.revokeObjectURL(a.href);
        log("Done. Downloaded sprite_index_clip.json — commit to public/ and deploy.");
      } catch (e) {
        log("ERROR: " + e.message);
      }
    };
  </script>
</body>
</html>
